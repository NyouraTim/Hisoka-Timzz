/**
 * Unirest for Node.js
 *
 * @author Nijko Yonskai
 * @copyright 2013-2015
 * @license MIT
 */

/**
 * Module Dependencies
 */

var StringDecoder = require('string_decoder').StringDecoder
var QueryString = require('querystring')
var FormData = require('form-data')
var Stream = require('stream')
var mime = require('mime')
var zlib = require('zlib')
var path = require('path')
var URL = require('url')
var fs = require('fs')

/**
 * Define form mime type
 */
mime.define({
  'application/x-www-form-urlencoded': ['form', 'urlencoded', 'form-data']
})

/**
 * Initialize our Rest Container
 *
 * @type {Object}
 */
var Unirest = function (method, uri, headers, body, callback) {
  var unirest = function (uri, headers, body, callback) {
    var $this = {
      /**
       * Stream Multipart form-data request
       *
       * @type {Boolean}
       */
      _stream: false,

      /**
       * Container to hold multipart form data for processing upon request.
       *
       * @type {Array}
       * @private
       */
      _multipart: [],

      /**
       * Container to hold form data for processing upon request.
       *
       * @type {Array}
       * @private
       */
      _form: [],

      /**
       * Request option container for details about the request.
       *
       * @type {Object}
       */
      options: {
        /**
         * Url obtained from request method arguments.
         *
         * @type {String}
         */
        url: uri,

        /**
         * Method obtained from request method arguments.
         *
         * @type {String}
         */
        method: method,

        /**
         * List of headers with case-sensitive fields.
         *
         * @type {Object}
         */
        headers: {}
      },

      hasHeader: function (name) {
        var headers
        var lowercaseHeaders

        name = name.toLowerCase()
        headers = Object.keys($this.options.headers)
        lowercaseHeaders = headers.map(function (header) {
          return header.toLowerCase()
        })

        for (var i = 0; i < lowercaseHeaders.length; i++) {
          if (lowercaseHeaders[i] === name) {
            return headers[i]
          }
        }

        return false
      },

      /**
       * Turn on multipart-form streaming
       *
       * @return {Object}
       */
      stream: function () {
        $this._stream = true
        return this
      },

      /**
       * Attaches a field to the multipart-form request, with pre-processing.
       *
       * @param  {String} name
       * @param  {String} value
       * @return {Object}
       */
      field: function (name, value, options) {
        return handleField(name, value, options)
      },

      /**
       * Attaches a file to the multipart-form request.
       *
       * @param  {String} name
       * @param  {String|Object} path
       * @return {Object}
       */
      attach: function (name, path, options) {
        options = options || {}
        options.attachment = true
        return handleField(name, path, options)
      },

      /**
       * Attaches field to the multipart-form request, with no pre-processing.
       *
       * @param  {String} name
       * @param  {String|Object} path
       * @param  {Object} options
       * @return {Object}
       */
      rawField: function (name, value, options) {
        $this._multipart.push({
          name: name,
          value: value,
          options: options,
          attachment: options.attachment || false
        })
      },

      /**
       * Basic Header Authentication Method
       *
       * Supports user being an Object to reflect Request
       * Supports user, password to reflect SuperAgent
       *
       * @param  {String|Object} user
       * @param  {String} password
       * @param  {Boolean} sendImmediately
       * @return {Object}
       */
      auth: function (user, password, sendImmediately) {
        $this.options.auth = (is(user).a(Object)) ? user : {
          user: user,
          password: password,
          sendImmediately: sendImmediately
        }

        return $this
      },

      /**
       * Sets header field to value
       *
       * @param  {String} field Header field
       * @param  {String} value Header field value
       * @return {Object}
       */
      header: function (field, value) {
        if (is(field).a(Object)) {
          for (var key in field) {
            if (Object.prototype.hasOwnProperty.call(field, key)) {
              $this.header(key, field[key])
            }
          }

          return $this
        }

        var existingHeaderName = $this.hasHeader(field)
        $this.options.headers[existingHeaderName || field] = value

        return $this
      },

      /**
       * Serialize value as querystring representation, and append or set on `Request.options.url`
       *
       * @param  {String|Object} value
       * @return {Object}
       */
      query: function (value) {
        if (is(value).a(Object)) value = Unirest.serializers.form(value)
        if (!value.length) return $this
        $this.options.url += (does($this.options.url).contain('?') ? '&' : '?') + value
        return $this
      },

      /**
       * Set _content-type_ header with type passed through `mime.getType()` when necessary.
       *
       * @param  {String} type
       * @return {Object}
       */
      type: function (type) {
        $this.header('Content-Type', does(type).contain('/')
          ? type
          : mime.getType(type))
        return $this
      },

      /**
       * Data marshalling for HTTP request body data
       *
       * Determines whether type is `form` or `json`.
       * For irregular mime-types the `.type()` method is used to infer the `content-type` header.
       *
       * When mime-type is `application/x-www-form-urlencoded` data is appended rather than overwritten.
       *
       * @param  {Mixed} data
       * @return {Object}
       */
      send: function (data) {
        var type = $this.options.headers[$this.hasHeader('content-type')]

        if ((is(data).a(Object) || is(data).a(Array)) && !Buffer.isBuffer(data)) {
          if (!type) {
            $this.type('form')
            type = $this.options.headers[$this.hasHeader('content-type')]
            $this.options.body = Unirest.serializers.form(data)
          } else if (~type.indexOf('json')) {
            $this.options.json = true

            if ($this.options.body && is($this.options.body).a(Object)) {
              for (var key in data) {
                if (Object.prototype.hasOwnProperty.call(data, key)) {
                  $this.options.body[key] = data[key]
                }
              }
            } else {
              $this.options.body = data
            }
          } else {
            $this.options.body = Unirest.Request.serialize(data, type)
          }
        } else if (is(data).a(String)) {
          if (!type) {
            $this.type('form')
            type = $this.options.headers[$this.hasHeader('content-type')]
          }

          if (type === 'application/x-www-form-urlencoded') {
            $this.options.body = $this.options.body
              ? $this.options.body + '&' + data
              : data
          } else {
            $this.options.body = ($this.options.body || '') + data
          }
        } else {
          $this.options.body = data
        }

        return $this
      },

      /**
       * Takes multipart options and places them on `options.multipart` array.
       * Transforms body when an `Object` or _content-type_ is present.
       *
       * Example:
       *
       *      Unirest.get('http://google.com').part({
       *        'content-type': 'application/json',
       *        body: {
       *          phrase: 'Hello'
       *        }
       *      }).part({
       *        'content-type': 'application/json',
       *        body: {
       *          phrase: 'World'
       *        }
       *      }).end(function (response) {})
       *
       * @param  {Object|String} options When an Object, headers should be placed directly on the object,
       *                                 not under a child property.
       * @return {Object}
       */
      part: function (options) {
        if (!$this._multipart) {
          $this.options.multipart = []
        }

        if (is(options).a(Object)) {
          if (options['content-type']) {
            var type = Unirest.type(options['content-type'], true)
            if (type) options.body = Unirest.Response.parse(options.body)
          } else {
            if (is(options.body).a(Object)) {
              options.body = Unirest.serializers.json(options.body)
            }
          }

          $this.options.multipart.push(options)
        } else {
          $this.options.multipart.push({
            body: options
          })
        }

        return $this
      },

      /**
       * Instructs the Request to be retried if specified error status codes (4xx, 5xx, ETIMEDOUT) are returned.
       * Retries are delayed with an exponential backoff.
       *
       * @param {(err: Error) => boolean} [callback] - Invoked on response error. Return false to stop next request.
       * @param {Object} [options] - Optional retry configuration to override defaults.
       * @param {number} [options.attempts=3] - The number of retry attempts.
       * @param {number} [options.delayInMs=250] - The delay in milliseconds (delayInMs *= delayMulti)
       * @param {number} [options.delayMulti=2] - The multiplier of delayInMs after each attempt.
       * @param {Array<string|number>} [options.statusCodes=["ETIMEDOUT", "5xx"]] - The status codes to retry on.
       * @return {Object}
       */
      retry: function (callback, options) {

        $this.options.retry = {
          callback: typeof callback === "function" ? callback : null,
          attempts: options && +options.attempts || 3,
          delayInMs: options && +options.delayInMs || 250,
          delayMulti: options && +options.delayMulti || 2,
          statusCodes: (options && options.statusCodes || ["ETIMEDOUT", "5xx"]).slice(0)
        };

        return $this
      },

      /**
       * Proxies the call to end. This adds support for using promises as well as async/await.
       *
       * @param  {Function} callback
       * @return {Promise}
       **/
      then: function (callback) {
        return new Promise((resolve, reject) => {
          this.end(result => {
            try {
              resolve(callback(result))
            } catch (err) {
              reject(err)
            }
          })
        })
      },

      /**
       * Sends HTTP Request and awaits Response finalization. Request compression